<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thử Thách Toán Học</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
        }
        .op-btn.active, .range-btn.active {
            background-color: #0ea5e9; color: white; transform: scale(1.05);
            box-shadow: 0 4px 14px 0 rgba(0, 118, 255, 0.39);
        }
        .calculation-area { font-family: 'Roboto Mono', monospace; font-weight: 700; }
        
        .simple-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-cols, 1), 1fr);
            justify-items: center; align-items: center; gap: 4px;
            padding: 1rem;
        }
        
        .grid-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-width: 2.5rem;
            height: 100%;
            position: relative;
        }
        .problem-digit { font-size: 2rem; color: #1e293b; }
        .operator-symbol { font-size: 2rem; color: #1e293b; justify-self: start; padding-left: 4px;}
        .grid-hr { grid-column: 1 / -1; width: 100%; height: 2px; background-color: #1e293b; margin: 0.5rem 0; }
        .answer-input {
            width: 100%;
            min-width: 2.5rem;
            height: 3.5rem;
            text-align: center;
            font-size: 2rem;
            border-width: 2px;
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin: 0.25rem;
            background-color: white;
            transition: all 0.2s ease;
        }
        .answer-input:focus {
            outline: none;
            border-color: #0ea5e9;
            box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.2);
        }
        .correct-digit { border-color: #22c55e; color: #22c55e; background-color: #f0fdf4; }
        .incorrect-digit { border-color: #ef4444; color: #ef4444; background-color: #fef2f2; }

        /* Division layout styles */
        .division-setup {
            position: relative;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .division-dividend {
            font-size: 2rem;
            color: #1e293b;
            padding-right: 1rem;
        }
        .division-divisor {
            position: relative;
            padding-left: 0.5rem;
            border-left: 2px solid #94a3b8;
            border-bottom: 2px solid #94a3b8;
            padding-bottom: 0.25rem;
        }
        .division-divisor::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 2px;
            height: 100%;
            background-color: #94a3b8;
        }

        @media (max-width: 640px) {
            .problem-digit, .operator-symbol { font-size: 1.5rem; }
            .answer-input { min-width: 2rem; height: 3rem; font-size: 1.5rem; padding: 0.25rem; margin: 0.125rem; }
            .answer-input { height: 3rem; font-size: 1.5rem; min-width: 2rem;}
            .division-dividend, .division-divisor { font-size: 1.5rem; }
        }

        /* Add new styles for difficulty buttons */
        .difficulty-btn {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .difficulty-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }
        .difficulty-btn.easy::after { background-color: #22c55e; }
        .difficulty-btn.medium::after { background-color: #eab308; }
        .difficulty-btn.hard::after { background-color: #ef4444; }
        .difficulty-btn.active::after { transform: scaleX(1); }
        .difficulty-btn.active.easy { background-color: #dcfce7; color: #166534; }
        .difficulty-btn.active.medium { background-color: #fef9c3; color: #854d0e; }
        .difficulty-btn.active.hard { background-color: #fee2e2; color: #991b1b; }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto bg-white rounded-2xl shadow-2xl p-6 sm:p-8 text-center">
        <h1 class="text-3xl font-bold text-slate-700 mb-2">Thử Thách Toán Học</h1>
        <p class="text-slate-500 mb-6">Chọn phép tính và độ khó!</p>

        <div class="bg-blue-500 text-white rounded-lg p-3 mb-6">
            <span class="text-lg">Điểm số:</span>
            <span id="score" class="text-2xl font-bold">0</span>
        </div>

        <div id="operator-choice" class="grid grid-cols-2 sm:grid-cols-4 gap-3 sm:gap-4 mb-4">
            <button data-op="+" class="op-btn w-full bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-3 px-4 rounded-lg text-2xl transition">+</button>
            <button data-op="-" class="op-btn w-full bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-3 px-4 rounded-lg text-2xl transition">−</button>
            <button data-op="*" class="op-btn w-full bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-3 px-4 rounded-lg text-2xl transition">×</button>
            <button data-op="/" class="op-btn w-full bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-3 px-4 rounded-lg text-2xl transition">÷</button>
        </div>

        <!-- Replace Range Selection Buttons with Difficulty Buttons -->
        <div id="difficulty-choice" class="grid grid-cols-3 gap-4 mb-6">
            <button data-difficulty="easy" class="difficulty-btn easy w-full bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-3 px-4 rounded-lg text-lg transition">
                <div class="font-bold mb-1">Dễ</div>
                <div class="text-sm text-slate-600">Số nhỏ, phép tính đơn giản</div>
            </button>
            <button data-difficulty="medium" class="difficulty-btn medium w-full bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-3 px-4 rounded-lg text-lg transition">
                <div class="font-bold mb-1">Trung bình</div>
                <div class="text-sm text-slate-600">Số vừa, có nhớ</div>
            </button>
            <button data-difficulty="hard" class="difficulty-btn hard w-full bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-3 px-4 rounded-lg text-lg transition">
                <div class="font-bold mb-1">Khó</div>
                <div class="text-sm text-slate-600">Số lớn, nhiều bước tính</div>
            </button>
        </div>

        <div id="calculation-area" class="mb-6 bg-slate-50 p-4 rounded-lg min-h-[150px]"></div>
        
        <div class="flex gap-4">
            <button id="check-btn" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-6 rounded-lg text-xl transition transform hover:scale-105">Kiểm Tra</button>
            <button id="check-again-btn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-6 rounded-lg text-xl transition transform hover:scale-105">Kiểm tra lại</button>
        </div>

        <div id="feedback" class="mt-6 text-xl sm:text-2xl font-bold h-8"></div>
    </div>

    <script>
        // DOM Elements
        const scoreElement = document.getElementById('score');
        const calculationArea = document.getElementById('calculation-area');
        const checkBtn = document.getElementById('check-btn');
        const checkAgainBtn = document.getElementById('check-again-btn');
        const feedbackElement = document.getElementById('feedback');
        const opButtons = document.querySelectorAll('.op-btn');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');

        // State
        let currentProblem = {};
        let score = 0;
        let currentDifficulty = 'medium'; // Default difficulty
        let retryCount = 0; // Add retry counter
        const MAX_RETRIES = 3; // Maximum number of retries

        // Difficulty settings with proper operator mapping
        const difficultySettings = {
            easy: {
                '+': { min: 1, max: 50, maxDigits: 2 },
                '-': { min: 1, max: 50, maxDigits: 2 },
                '*': { min: 1, max: 10, maxDigits: 2, maxMultiplierDigits: 2 },
                '/': { 
                    min: 1, 
                    max: 50, 
                    maxDivisor: 10, 
                    maxQuotient: 10,
                    maxDigits: 2,
                    divisorDigits: 1
                }
            },
            medium: {
                '+': { min: 1000, max: 100000, maxDigits: 6 },
                '-': { min: 1000, max: 100000, maxDigits: 6 },
                '*': { min: 10, max: 100, maxDigits: 3, maxMultiplierDigits: 3 },
                '/': { 
                    min: 20, 
                    max: 500, 
                    maxDivisor: 20, 
                    maxQuotient: 25,
                    maxDigits: 3,
                    divisorDigits: 2
                }
            },
            hard: {
                '+': { min: 10000, max: 10000000, maxDigits: 8 },
                '-': { min: 10000, max: 10000000, maxDigits: 8 },
                '*': { min: 100, max: 1000, maxDigits: 4, maxMultiplierDigits: 3 },
                '/': { 
                    min: 100, 
                    max: 10000, 
                    maxDivisor: 50, 
                    maxQuotient: 200,
                    maxDigits: 4,
                    divisorDigits: 2
                }
            }
        };

        // Utility Functions
        function getRandomNumber(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        
        function requestNewProblem(operator) {
            retryCount = 0; // Reset retry counter
            opButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.op === operator));
            generateProblem(operator);
            feedbackElement.textContent = '';
            checkBtn.disabled = false;
        }
        
        function createDigitInputs(count, groupName) {
            let html = '';
            for (let i = 0; i < count; i++) {
                html += `<div class="grid-item"><input type="text" maxlength="1" class="answer-input" data-group="${groupName}" data-index="${i}" /></div>`;
            }
            return html;
        }

        /** --- Problem Generation --- */
        function getRandomNumberInRange(min, max, maxDigits) {
            // Ensure all parameters are valid numbers
            min = Number(min);
            max = Number(max);
            maxDigits = Number(maxDigits);

            // Validate parameters
            if (isNaN(min) || isNaN(max) || isNaN(maxDigits)) {
                console.error('Invalid parameters for getRandomNumberInRange:', { min, max, maxDigits });
                return NaN;
            }

            // Ensure min and max are valid numbers and within bounds
            min = Math.max(1, Math.floor(min));
            max = Math.max(min, Math.floor(max));
            
            // Calculate maximum possible value based on digits
            const maxValue = Math.min(max, Math.pow(10, maxDigits) - 1);
            
            // Ensure we have a valid range
            if (min > maxValue) {
                console.error('Invalid range in getRandomNumberInRange:', { min, max, maxValue, maxDigits });
                return NaN;
            }

            const result = Math.floor(Math.random() * (maxValue - min + 1)) + min;
            console.log('getRandomNumberInRange result:', { min, max, maxDigits, maxValue, result });
            return result;
        }

        function generateProblem(operator) {
            if (retryCount >= MAX_RETRIES) {
                console.error('Max retries reached, falling back to addition');
                operator = '+';
                retryCount = 0;
            }

            currentProblem = { type: operator };
            calculationArea.innerHTML = '';
            calculationArea.className = 'mb-6 bg-slate-50 p-4 rounded-lg min-h-[150px] calculation-area';
            
            // Get settings for current difficulty and operator
            const settings = difficultySettings[currentDifficulty][operator];
            if (!settings) {
                console.error('Invalid operator or difficulty settings:', { operator, currentDifficulty });
                return;
            }

            console.log('Current settings:', {
                difficulty: currentDifficulty,
                operator,
                settings
            });

            let num1, num2;

            try {
                switch(operator) {
                    case '+':
                        num1 = getRandomNumberInRange(settings.min, settings.max, settings.maxDigits);
                        num2 = getRandomNumberInRange(settings.min, settings.max, settings.maxDigits);
                        if (isNaN(num1) || isNaN(num2)) throw new Error('Invalid numbers generated for addition');
                        currentProblem.answer = num1 + num2;
                        setupSimpleGridProblem(num1, num2, '+');
                        break;
                    case '-':
                        num1 = getRandomNumberInRange(settings.min, settings.max, settings.maxDigits);
                        num2 = getRandomNumberInRange(settings.min, num1, settings.maxDigits);
                        if (isNaN(num1) || isNaN(num2)) throw new Error('Invalid numbers generated for subtraction');
                        currentProblem.answer = num1 - num2;
                        setupSimpleGridProblem(num1, num2, '−');
                        break;
                    case '*':
                        num1 = getRandomNumberInRange(settings.min, settings.max, settings.maxDigits);
                        // Generate multiplier with appropriate number of digits
                        const maxMultiplier = Math.min(settings.max, Math.pow(10, settings.maxMultiplierDigits) - 1);
                        num2 = getRandomNumberInRange(settings.min, maxMultiplier, settings.maxMultiplierDigits);
                        if (isNaN(num1) || isNaN(num2)) throw new Error('Invalid numbers generated for multiplication');
                        currentProblem.answer = num1 * num2;
                        currentProblem.partialProducts = num2.toString().split('').reverse().map(digit => num1 * parseInt(digit));
                        setupSimpleGridProblem(num1, num2, '×');
                        break;
                    case '/':
                        // For division, generate numbers in a more controlled way
                        if (currentDifficulty === 'easy') {
                            // Easy: Single digit divisor, clean division
                            num2 = getRandomNumberInRange(2, Math.min(settings.maxDivisor, 9), settings.divisorDigits);
                            if (isNaN(num2)) throw new Error('Invalid divisor generated for easy division');
                            
                            const multiplier = getRandomNumberInRange(1, Math.min(settings.maxQuotient, 10), settings.maxDigits);
                            if (isNaN(multiplier)) throw new Error('Invalid multiplier generated for easy division');
                            
                            num1 = num2 * multiplier;
                        } else {
                            // Medium and Hard: Generate divisor first, then dividend
                            num2 = getRandomNumberInRange(2, settings.maxDivisor, settings.divisorDigits);
                            if (isNaN(num2)) throw new Error('Invalid divisor generated for division');
                            
                            // Calculate maximum possible quotient
                            const maxQuotient = Math.min(
                                settings.maxQuotient,
                                Math.floor(settings.max / num2),
                                Math.pow(10, settings.maxDigits) - 1
                            );
                            
                            if (maxQuotient < 1) {
                                throw new Error('Invalid maxQuotient calculated for division');
                            }
                            
                            const multiplier = getRandomNumberInRange(1, maxQuotient, settings.maxDigits);
                            if (isNaN(multiplier)) throw new Error('Invalid multiplier generated for division');
                            
                            num1 = num2 * multiplier;
                            
                            // For medium and hard, sometimes add a remainder
                            if (currentDifficulty !== 'easy' && Math.random() < 0.5) {
                                const remainder = getRandomNumberInRange(1, num2 - 1, settings.maxDigits);
                                if (!isNaN(remainder)) {
                                    num1 += remainder;
                                }
                            }
                        }

                        console.log('Generating division problem:', {
                            difficulty: currentDifficulty,
                            settings,
                            num1,
                            num2,
                            quotient: Math.floor(num1 / num2),
                            remainder: num1 % num2,
                            retryCount,
                            maxQuotient: settings.maxQuotient,
                            maxDivisor: settings.maxDivisor,
                            maxDigits: settings.maxDigits,
                            divisorDigits: settings.divisorDigits
                        });

                        if (isNaN(num1) || isNaN(num2) || num2 === 0 || num1 < num2) {
                            throw new Error('Invalid numbers generated for division');
                        }

                        currentProblem.quotient = Math.floor(num1 / num2);
                        currentProblem.remainder = num1 % num2;
                        setupDivisionProblem(num1, num2);
                        break;
                    default:
                        throw new Error('Invalid operator: ' + operator);
                }
            } catch (error) {
                console.error('Error generating problem:', error, { 
                    retryCount,
                    difficulty: currentDifficulty,
                    operator,
                    settings
                });
                retryCount++;
                // Retry with the same operator
                setTimeout(() => generateProblem(operator), 0);
                return;
            }
        }
        
        function setupSimpleGridProblem(num1, num2, op) {
            calculationArea.classList.add('simple-grid');
            const num1Str = num1.toString(), num2Str = num2.toString(), answerStr = (currentProblem.answer || '').toString();
            let content = '';
            
            if (op === '×') {
                // Calculate partial products
                const num2Digits = num2Str.split('').reverse();
                currentProblem.partialProducts = [];
                
                num2Digits.forEach((digit, index) => {
                    const partialProduct = num1 * parseInt(digit);
                    currentProblem.partialProducts.push(partialProduct);
                });

                // Calculate total length needed for display
                const longestPartial = currentProblem.partialProducts.reduce((max, p) => Math.max(max, p.toString().length), 0);
                const maxLength = Math.max(
                    num1Str.length,
                    num2Str.length,
                    answerStr.length,
                    longestPartial + num2Str.length - 1
                );
                
                // Set grid columns to accommodate the widest number plus operator column
                calculationArea.style.setProperty('--grid-cols', maxLength + 1);

                // First row: First number
                content += `<div class="grid-item"></div>`; // Operator column
                content += `${'<div class="grid-item"></div>'.repeat(maxLength - num1Str.length)}`; // Leading spaces
                content += num1Str.split('').map(d => `<div class="grid-item problem-digit">${d}</div>`).join('');
                
                // Second row: Operator and second number
                content += `<div class="grid-item operator-symbol">${op}</div>`;
                content += `${'<div class="grid-item"></div>'.repeat(maxLength - num2Str.length)}`; // Leading spaces
                content += num2Str.split('').map(d => `<div class="grid-item problem-digit">${d}</div>`).join('');
                
                // Horizontal line
                content += '<div class="grid-hr"></div>';
                
                // Add partial products with proper alignment
                currentProblem.partialProducts.forEach((product, index) => {
                    const pStr = product.toString();
                    const indent = index;
                    
                    // Calculate proper spacing for this step
                    const leadingSpaces = maxLength - (pStr.length + indent);
                    
                    // Add leading spaces (including operator column)
                    content += `<div class="grid-item"></div>`; // Operator column
                    content += `${'<div class="grid-item"></div>'.repeat(leadingSpaces)}`; // Leading spaces
                    
                    // Add input boxes for partial product
                    content += createDigitInputs(pStr.length, `partial_${index}`);
                    
                    // Add trailing spaces
                    content += `${'<div class="grid-item"></div>'.repeat(indent)}`;
                    
                    // Add horizontal line after each step except the last one
                    if (index < currentProblem.partialProducts.length - 1) {
                        content += '<div class="grid-hr"></div>';
                    }
                });
                
                // Add final horizontal line
                content += '<div class="grid-hr"></div>';
                
                // Add final answer input with proper alignment
                const answerSpaces = maxLength - answerStr.length;
                content += `<div class="grid-item"></div>`; // Operator column
                content += `${'<div class="grid-item"></div>'.repeat(answerSpaces)}`; // Leading spaces
                content += createDigitInputs(answerStr.length, 'answer');
            } else {
                // For other operations
                const maxLength = Math.max(num1Str.length, num2Str.length, answerStr.length);
                calculationArea.style.setProperty('--grid-cols', maxLength + 1);
                
                // First row: First number
                content += `<div class="grid-item"></div>`;
                content += `${'<div class="grid-item"></div>'.repeat(maxLength - num1Str.length)}`;
                content += num1Str.split('').map(d => `<div class="grid-item problem-digit">${d}</div>`).join('');
                
                // Second row: Operator and second number
                content += `<div class="grid-item operator-symbol">${op}</div>`;
                content += `${'<div class="grid-item"></div>'.repeat(maxLength - num2Str.length)}`;
                content += num2Str.split('').map(d => `<div class="grid-item problem-digit">${d}</div>`).join('');
                
                // Horizontal line
                content += '<div class="grid-hr"></div>';
                
                // Add answer input
                content += `${'<div class="grid-item"></div>'.repeat(maxLength + 1 - answerStr.length)}`;
                content += createDigitInputs(answerStr.length, 'answer');
            }
            
            calculationArea.innerHTML = content;
            
            // Add event listeners for immediate validation and focus handling
            if (op === '×') {
                const inputs = calculationArea.querySelectorAll('input[data-group^="partial_"]');
                inputs.forEach(input => {
                    // Prevent focus loss on click
                    input.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        input.focus();
                    });

                    input.addEventListener('input', (e) => {
                        const [_, stepIndex] = e.target.dataset.group.split('_');
                        const stepProduct = currentProblem.partialProducts[stepIndex];
                        const userAnswer = e.target.value;
                        const currentIndex = parseInt(e.target.dataset.index);
                        
                        // Only allow numbers
                        e.target.value = userAnswer.replace(/[^0-9]/g, '');
                        
                        // Move to next input if current input is filled
                        if (e.target.value.length === 1) {
                            const nextInput = e.target.closest('.grid-item').nextElementSibling?.querySelector('input');
                            if (nextInput) {
                                nextInput.focus();
                            }
                        }
                        
                        // Validate when input is complete
                        const stepInputs = calculationArea.querySelectorAll(`input[data-group="partial_${stepIndex}"]`);
                        const completeAnswer = Array.from(stepInputs).map(input => input.value).join('');
                        
                        if (completeAnswer.length === stepProduct.toString().length) {
                            const isCorrect = parseInt(completeAnswer) === stepProduct;
                            stepInputs.forEach(input => {
                                input.classList.toggle('correct-digit', isCorrect);
                                input.classList.toggle('incorrect-digit', !isCorrect);
                                if (isCorrect) {
                                    input.readOnly = true;
                                    setTimeout(() => input.classList.remove('correct-digit'), 1000);
                                }
                            });
                            
                            if (!isCorrect) {
                                setTimeout(() => {
                                    stepInputs.forEach(input => {
                                        input.classList.remove('incorrect-digit');
                                        if (!input.readOnly) {
                                            input.value = '';
                                        }
                                    });
                                    stepInputs[0].focus();
                                }, 1000);
                            }
                        }
                    });

                    // Handle backspace to move to previous input
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Backspace' && e.target.value === '') {
                            const prevInput = e.target.closest('.grid-item').previousElementSibling?.querySelector('input');
                            if (prevInput) {
                                prevInput.focus();
                            }
                        }
                    });
                });
            }
        }

        function validateMultiplicationStep(stepIndex, userAnswer) {
            const step = currentProblem.partialSteps[stepIndex];
            if (!step) return false;
            
            const userValue = parseInt(userAnswer) || 0;
            const isCorrect = userValue === step.product;
            
            console.log('Validating multiplication step:', {
                stepIndex,
                step,
                userAnswer,
                isCorrect,
                explanation: step.explanation
            });
            
            return isCorrect;
        }

        // Update the check button logic to handle multiplication steps
        function checkAllSteps() {
            if (currentProblem.type === '×') {
                let allCorrect = true;
                const inputs = calculationArea.querySelectorAll('input');
                
                // Check all partial products
                currentProblem.partialProducts.forEach((product, index) => {
                    const stepInputs = calculationArea.querySelectorAll(`input[data-group="partial_${index}"]`);
                    const userAnswer = Array.from(stepInputs).map(input => input.value).join('');
                    
                    if (parseInt(userAnswer) !== product) {
                        allCorrect = false;
                        stepInputs.forEach(input => {
                            input.classList.add('incorrect-digit');
                            setTimeout(() => {
                                input.classList.remove('incorrect-digit');
                                if (!input.readOnly) {
                                    input.value = '';
                                }
                            }, 1000);
                        });
                    }
                });
                
                // Check final answer
                const answerInputs = calculationArea.querySelectorAll('input[data-group="answer"]');
                const userAnswer = Array.from(answerInputs).map(input => input.value).join('');
                const correctAnswer = currentProblem.answer.toString();
                
                if (userAnswer !== correctAnswer) {
                    allCorrect = false;
                    answerInputs.forEach(input => {
                        input.classList.add('incorrect-digit');
                        setTimeout(() => {
                            input.classList.remove('incorrect-digit');
                            if (!input.readOnly) {
                                input.value = '';
                            }
                        }, 1000);
                    });
                }
                
                return allCorrect;
            } else {
                // For other operations (addition, subtraction)
                const answerInputs = calculationArea.querySelectorAll('input[data-group="answer"]');
                const userAnswer = Array.from(answerInputs).map(input => input.value).join('');
                const correctAnswer = currentProblem.answer.toString();
                
                if (userAnswer !== correctAnswer) {
                    answerInputs.forEach(input => {
                        input.classList.add('incorrect-digit');
                        setTimeout(() => {
                            input.classList.remove('incorrect-digit');
                            if (!input.readOnly) {
                                input.value = '';
                            }
                        }, 1000);
                    });
                    return false;
                }
                return true;
            }
        }

        function setupDivisionProblem(dividend, divisor) {
            calculationArea.classList.remove('simple-grid');
            calculationArea.classList.add('flex', 'flex-col', 'items-center', 'justify-center', 'gap-2');
            
            // Store initial values
            currentProblem.dividend = dividend;
            currentProblem.divisor = divisor;
            currentProblem.currentStep = 0;
            currentProblem.userAnswers = [];
            currentProblem.quotient = Math.floor(dividend / divisor);
            currentProblem.remainder = dividend % divisor;
            currentProblem.stepsContainer = null; // Add reference to steps container
            
            // Calculate initial steps
            const steps = calculateDivisionSteps(dividend, divisor);
            currentProblem.steps = steps;
            
            let content = '';
            // Display the division setup with dividend on left and divisor on right
            content += `
                <div class="division-setup">
                    <div class="division-dividend">${dividend}</div>
                    <div class="division-divisor">
                        <div class="problem-digit">${divisor}</div>
                    </div>
                </div>
                <div id="division-steps" class="w-full"></div>
            `;

            calculationArea.innerHTML = content;
            
            // Store reference to steps container
            currentProblem.stepsContainer = document.getElementById('division-steps');
            
            // Show first step
            showDivisionStep(0, true);

            // Focus the first input
            const firstInput = currentProblem.stepsContainer.querySelector('input');
            if (firstInput) {
                firstInput.focus();
            }
        }

        function showDivisionStep(stepIndex, isActive) {
            if (!currentProblem.stepsContainer || !currentProblem.steps[stepIndex]) return;
            
            const step = currentProblem.steps[stepIndex];
            const stepElement = document.createElement('div');
            stepElement.className = `division-step ${stepIndex > 0 ? 'mt-2' : ''}`;
            stepElement.dataset.stepIndex = stepIndex;
            
            // Calculate max length for remainder input based on the number
            const remainderLength = step.remainder.toString().length;
            const maxLength = Math.max(remainderLength, 2); // At least 2 digits, or more if needed
            
            const stepContent = `
                <div class="flex flex-col items-center gap-1">
                    ${stepIndex === 0 ? '' : 
                        `<div class="text-slate-400">${'&nbsp;'.repeat(step.indent)}${step.currentNumber}</div>`
                    }
                    <div class="flex items-center gap-2">
                        ${'&nbsp;'.repeat(step.indent)}
                        ${isActive ? 
                            `<input type="text" class="answer-input w-12 text-center" data-step="${stepIndex}_times" maxlength="1" placeholder="?" pattern="[0-9]*" inputmode="numeric">` :
                            `<span class="text-slate-400">${step.times}</span>`
                        }
                        <span class="text-slate-400">× ${currentProblem.divisor} =</span>
                        ${isActive ? 
                            `<input type="text" class="answer-input w-16 text-center" data-step="${stepIndex}_multiply" maxlength="3" placeholder="?" pattern="[0-9]*" inputmode="numeric">` :
                            `<span class="text-slate-400">${step.multiply}</span>`
                        }
                    </div>
                    <div class="grid-hr w-32"></div>
                    <div class="flex items-center gap-2">
                        ${'&nbsp;'.repeat(step.indent)}
                        ${isActive ? 
                            `<input type="text" class="answer-input w-${maxLength * 8 + 16}px text-center" data-step="${stepIndex}_remainder" maxlength="${maxLength}" placeholder="?" pattern="[0-9]*" inputmode="numeric">` :
                            `<span>${step.remainder}</span>`
                        }
                    </div>
                </div>
            `;
            
            stepElement.innerHTML = stepContent;
            currentProblem.stepsContainer.appendChild(stepElement);

            // Add input event listeners for immediate validation
            if (isActive) {
                const inputs = stepElement.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('input', (e) => {
                        // Only allow numbers
                        e.target.value = e.target.value.replace(/[^0-9]/g, '');
                        
                        // Update user's answer
                        if (!currentProblem.userAnswers[stepIndex]) {
                            currentProblem.userAnswers[stepIndex] = {};
                        }
                        const [_, type] = e.target.dataset.step.split('_');
                        currentProblem.userAnswers[stepIndex][type] = e.target.value;
                        
                        console.log('Input updated:', {
                            stepIndex,
                            type,
                            value: e.target.value,
                            currentStep: step,
                            userAnswers: currentProblem.userAnswers[stepIndex]
                        });
                    });
                });
            }
        }

        function calculateDivisionSteps(dividend, divisor) {
            if (isNaN(dividend) || isNaN(divisor) || divisor === 0) {
                console.error('Invalid division parameters:', { dividend, divisor });
                return [];
            }

            const steps = [];
            const dividendStr = dividend.toString();
            let currentNumber = '';
            let currentQuotient = '';
            let indent = 0;
            
            console.log('Starting division calculation:', { 
                dividend, 
                divisor,
                dividendStr,
                difficulty: currentDifficulty
            });
            
            for (let i = 0; i < dividendStr.length; i++) {
                currentNumber += dividendStr[i];
                let num = parseInt(currentNumber);
                
                if (isNaN(num)) {
                    console.error('Invalid number in division step:', { currentNumber, digit: dividendStr[i] });
                    continue;
                }
                
                console.log('Processing digit:', {
                    digit: dividendStr[i],
                    currentNumber: num,
                    divisor: divisor,
                    step: i + 1
                });
                
                if (num >= divisor) {
                    const times = Math.floor(num / divisor);
                    const multiply = times * divisor;
                    const remainder = num - multiply;
                    
                    console.log('Calculating step:', {
                        step: steps.length + 1,
                        currentNumber: num,
                        divisor: divisor,
                        times: times,
                        multiply: multiply,
                        remainder: remainder,
                        calculation: `${num} - ${multiply} = ${remainder}`
                    });
                    
                    steps.push({
                        stepNumber: steps.length + 1,
                        currentNumber: num,
                        times: times,
                        multiply: multiply,
                        remainder: remainder,
                        indent: indent,
                        quotientDigit: times
                    });
                    
                    currentNumber = remainder.toString();
                    currentQuotient += times;
                    indent++;
                } else if (i === dividendStr.length - 1) {
                    console.log('Final step:', {
                        currentNumber: num,
                        remainder: num,
                        step: steps.length + 1
                    });
                    
                    steps.push({
                        stepNumber: steps.length + 1,
                        currentNumber: num,
                        times: 0,
                        multiply: 0,
                        remainder: num,
                        indent: indent,
                        quotientDigit: 0
                    });
                }
            }
            
            console.log('Division steps calculated:', {
                steps,
                finalQuotient: currentQuotient,
                finalRemainder: currentNumber
            });
            
            return steps;
        }

        /** --- Event Listeners --- */
        calculationArea.addEventListener('input', (e) => {
            if (e.target.tagName === 'INPUT' && e.target.dataset.step) {
                const [stepIndex, type] = e.target.dataset.step.split('_');
                const currentStep = currentProblem.steps[stepIndex];
                
                if (!currentStep) {
                    console.log('No step found for index:', stepIndex);
                    return;
                }

                // Only allow numbers
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                
                // Store user's answer as string
                if (!currentProblem.userAnswers[stepIndex]) {
                    currentProblem.userAnswers[stepIndex] = {};
                }
                currentProblem.userAnswers[stepIndex][type] = e.target.value;

                // Check if all inputs for this step are filled
                const stepElement = currentProblem.stepsContainer.querySelector(`[data-step-index="${stepIndex}"]`);
                if (!stepElement) return;
                
                const stepInputs = stepElement.querySelectorAll('input');
                const allFilled = Array.from(stepInputs).every(input => input.value !== '');
                
                if (allFilled) {
                    console.log('All inputs filled for step:', stepIndex);
                    // Validate the step
                    const isCorrect = validateDivisionStep(stepIndex);
                    console.log('Step validation result:', isCorrect);
                    
                    if (isCorrect) {
                        // Show correct state
                        stepInputs.forEach(input => {
                            input.classList.add('correct-digit');
                            input.readOnly = true; // Make inputs readonly after correct
                            setTimeout(() => input.classList.remove('correct-digit'), 1000);
                        });

                        // Move to next step if available
                        if (stepIndex < currentProblem.steps.length - 1) {
                            // Remove any existing next steps
                            const nextSteps = currentProblem.stepsContainer.querySelectorAll(`[data-step-index="${parseInt(stepIndex) + 1}"]`);
                            nextSteps.forEach(step => step.remove());
                            
                            // Show next step
                            showDivisionStep(parseInt(stepIndex) + 1, true);
                            
                            // Focus the first input of the next step
                            const nextInput = currentProblem.stepsContainer.querySelector(`input[data-step="${parseInt(stepIndex) + 1}_times"]`);
                            if (nextInput) {
                                nextInput.focus();
                            }
                        } else {
                            // All steps completed, show final answer input
                            const finalAnswerContent = `
                                <div class="flex items-center justify-center gap-4 mt-4 text-2xl">
                                    <span class="problem-digit">=</span>
                                    <input type="text" class="answer-input w-32" data-group="quotient" placeholder="Thương" pattern="[0-9]*" inputmode="numeric">
                                    <span class="problem-digit text-xl">dư</span>
                                    <input type="text" class="answer-input w-24" data-group="remainder" placeholder="Số dư" pattern="[0-9]*" inputmode="numeric">
                                </div>
                            `;
                            const finalContainer = document.createElement('div');
                            finalContainer.innerHTML = finalAnswerContent;
                            currentProblem.stepsContainer.appendChild(finalContainer.firstElementChild);
                            
                            // Focus the quotient input
                            const quotientInput = currentProblem.stepsContainer.querySelector('input[data-group="quotient"]');
                            if (quotientInput) {
                                quotientInput.focus();
                            }
                        }
                    } else {
                        // Show error state
                        stepInputs.forEach(input => {
                            input.classList.add('incorrect-digit');
                            setTimeout(() => {
                                input.classList.remove('incorrect-digit');
                                if (!input.readOnly) { // Only clear if not readonly
                                    input.value = '';
                                }
                            }, 1000);
                        });
                    }
                }
            }
        });

        opButtons.forEach(button => button.addEventListener('click', (e) => requestNewProblem(e.target.dataset.op)));
        
        difficultyButtons.forEach(button => {
            button.addEventListener('click', e => {
                const difficulty = e.target.closest('.difficulty-btn').dataset.difficulty;
                if (!difficulty || !difficultySettings[difficulty]) {
                    console.error('Invalid difficulty:', difficulty);
                    return;
                }
                currentDifficulty = difficulty;
                difficultyButtons.forEach(btn => btn.classList.remove('active'));
                e.target.closest('.difficulty-btn').classList.add('active');
                const activeOpButton = document.querySelector('.op-btn.active');
                if (activeOpButton) {
                    requestNewProblem(activeOpButton.dataset.op);
                } else {
                    requestNewProblem('+');
                }
            });
        });

        // Add event listener for check again button
        checkAgainBtn.addEventListener('click', () => {
            const isAllCorrect = checkAllSteps();
            
            feedbackElement.classList.remove('text-green-500', 'text-red-500');
            if (isAllCorrect) {
                feedbackElement.textContent = 'Tất cả các bước đều chính xác!';
                feedbackElement.classList.add('text-green-500');
            } else {
                feedbackElement.textContent = 'Có lỗi trong các bước tính, hãy kiểm tra lại!';
                feedbackElement.classList.add('text-red-500');
            }
        });

        // Update the existing check button to also use checkAllSteps
        checkBtn.addEventListener('click', () => {
            const isAllCorrect = checkAllSteps();
            
            feedbackElement.classList.remove('text-green-500', 'text-red-500');
            if (isAllCorrect) {
                score++;
                scoreElement.textContent = score;
                feedbackElement.textContent = 'Chính xác! Quá giỏi!';
                feedbackElement.classList.add('text-green-500');
                checkBtn.disabled = true;
            } else {
                feedbackElement.textContent = 'Vẫn còn lỗi sai, kiểm tra lại nhé!';
                feedbackElement.classList.add('text-red-500');
            }
        });

        // Initial load
        window.onload = () => {
            const defaultOp = '+';
            const defaultDifficulty = 'medium';
            
            // Validate default settings
            if (!difficultySettings[defaultDifficulty] || !difficultySettings[defaultDifficulty][defaultOp]) {
                console.error('Invalid default settings:', { defaultDifficulty, defaultOp });
                return;
            }

            document.querySelector(`.op-btn[data-op="${defaultOp}"]`).classList.add('active');
            document.querySelector(`.difficulty-btn[data-difficulty="${defaultDifficulty}"]`).classList.add('active');
            requestNewProblem(defaultOp);
        };
    </script>
</body>
</html>
